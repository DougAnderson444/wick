<%

const inputs = data.definitions.find(def => def.kind === 'TypeDefinition' && def.name.value === 'Inputs');
const outputs = data.definitions.find(def => def.kind === 'TypeDefinition' && def.name.value === 'Outputs');

function portStruct(port){return `GuestPort${utils.pascalCase(helpers.fieldName(port.name.value))}`};
%>

use crate::components::native_component_actor::NativeCallback;
use crate::{ Result};
use vino_codec::messagepack::{
  deserialize,
  serialize,
};
use serde::{Deserialize, Serialize};
use vino_component::OutputPayload;

pub(crate) struct Inputs {
  <% for (let input of Object.values(inputs.fields)) { %>
    pub (crate) <%- helpers.fieldName(input.name.value) %>: <%- helpers.expandType(input.type) %>,
  <% } %>
}

pub(crate) fn inputs_list() -> Vec<String> {
    vec![<%- inputs.fields.map(f => `"${f.name.value}".to_string()`).join(",") %>]
}

pub (crate) struct Outputs<'a> {
    <% for (let output of Object.values(outputs.fields)) { %>
    pub (crate) <%- helpers.fieldName(output.name.value) %>: <%- portStruct(output) %><'a>,
    <% } %>
}

pub(crate) fn outputs_list() -> Vec<String> {
    vec![<%- outputs.fields.map(f => `"${f.name.value}".to_string()`).join(",") %>]
}

<% for (let output of Object.values(outputs.fields)) { %>
pub (crate) struct <%- portStruct(output) %><'a> {
    inv_id: String,
    callback: &'a NativeCallback,
}
impl<'a>  <%- portStruct(output) %><'a> {
    #[allow(dead_code)]
    pub (crate) fn send(&self, payload: <%- helpers.expandType(output.type) %>) -> Result<()> {
        (self.callback)(
            0,
            &self.inv_id,
            "",
            "<%- helpers.fieldName(output.name.value) %>",
            &OutputPayload::MessagePack(serialize(payload)?),
        )?;
        Ok(())
    }
    #[allow(dead_code)]
    pub (crate) fn exception(&self, message: String) -> Result<()> {
        (self.callback)(
            0,
            &self.inv_id,
            "",
            "<%- helpers.fieldName(output.name.value) %>",
            &OutputPayload::Exception(message),
        )?;
        Ok(())
    }
}
<% } %>

pub (crate) fn get_outputs(callback: &NativeCallback, inv_id: String) -> Outputs {
    Outputs {
        <%
        let fields = Object.values(outputs.fields);
        for (let i = 0; i < fields.length;i++) {
          let output = fields[i];
        %>
        <%- helpers.fieldName(output.name.value) %>: <%- portStruct(output) %> {
            inv_id<%- i === fields.length - 1 ? '' : ': inv_id.to_string()' %>,
            callback,
        },
        <% } %>
    }
}


#[derive(Debug, PartialEq, Deserialize, Serialize, Default, Clone)]
pub (crate) struct InputEncoded {
    <% for (let input of Object.values(inputs.fields)) { %>
    #[serde(rename = "<%- helpers.fieldName(input.name.value) %>")]
    pub <%- helpers.fieldName(input.name.value) %>: Vec<u8>,
    <% } %>
}
pub (crate) fn deserialize_inputs(
    args: InputEncoded,
) -> std::result::Result<
    Inputs, Box<dyn std::error::Error + Send + Sync>,
> {
    Ok(Inputs {
        <% for (let input of Object.values(inputs.fields)) { %>
        <%- helpers.fieldName(input.name.value) %>: deserialize(&args.<%- helpers.fieldName(input.name.value) %>)?,
        <% } %>
    })
}
